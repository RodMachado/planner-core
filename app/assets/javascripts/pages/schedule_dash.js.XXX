# Place all the behaviors and hooks related to the matching controller here.
# All this logic will automatically be available in application.js.
# You can use CoffeeScript in this file: http://jashkenas.github.com/coffee-script/

window.Schedule = {} # Namespace to use so that the methods can accessed by the other components
# window.Schedule.xscale = (data) -> d3.scale.linear().domain([0, d3.max(data)]).range([0, 420])
# window.Schedule.timeScale = (data) -> d3.time.scale().range([0, w])

#
# The Canvas that we will be working in plus it's margins
#
margin = {top: 40, right: 15, bottom: 15, left: 40}
width  = 600 - margin.left - margin.right
height = 680 - margin.top - margin.bottom

t1 = new Date(2013, 0, 1)
t2 = new Date(2013, 0, 2)
t0 = d3.time.month.offset(t1, -1)
t3 = d3.time.minute.offset(t2, +15)

xScale = d3.scale.linear().range([0,width])
yScale = d3.time.scale().range([0, height]) 
    
    #[t1,t3].map(d3.time.scale().domain([t1, t2]).range([0, height*2]))) # Show half a day (and start it at 8am ...))
    # .domain([t1, t2]) # The date range as input
      # [t0, t3].map(
          # d3.time.scale().domain([t1, t2]).range([0, height]))
        # )
  # .ticks(d3.time.minute, 15)
  
xAxis = d3.svg.axis()
    .scale(xScale)
    .orient("top")
    .tickSize(-height, 0)
    .tickPadding(6)

#yAxis =  d3.svg.axis().scale(yScale).orient("left").ticks(d3.time.hour, 1)
yAxis = d3.svg.axis()
    .scale(yScale)
    .orient("left")
    .tickSize(-width)
    .tickPadding(6);

ff = (d) -> xScale(d)
gg = (d) -> yScale(d)

line = d3.svg.line()
    .interpolate("step-after")
    .x( ff )
    .y( gg )

zoom = d3.behavior.zoom().on("zoom", draw)

selector = null
data = null
svg = null

#
# Paint the schedule as a grid
#
window.Schedule.paint = (_selector, _data) ->
  selector = _selector
  data = _data
  # Create the canvas
  svg = d3.select(selector).append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");  
  
  # svg = d3.select(selector).append("svg")
    # .attr("class", "pane")
    # .attr("width", width + margin.left + margin.right)
    # .attr("height", height + margin.top + margin.bottom)
    # .append("g")
    # .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
  #
  svg.append("clipPath")
    .attr("id", "clip")
    .append("rect")
      .attr("x", xScale(0))
      .attr("y", yScale(1))
      .attr("width", xScale(1) - xScale(0))
      .attr("height", yScale(0) - yScale(1));
      
  # Add the time axis
  svg.append("g")
    .attr("class", "y axis")
    .attr("transform", "translate(0,0)")
    .call(yAxis)
  svg.append("path")
    .attr("class", "line")
    .attr("clip-path", "url(#clip)");
  svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0,0)")
    .call(xAxis)
  svg.append("rect")
    .attr("class", "pane")
    .attr("width", width)
    .attr("height", height)
    .call(d3.behavior.zoom().on("zoom", draw))
  
  yScale.domain([t1, d3.time.hour.offset(t2, -6)]) # The date range as input
  d3.behavior.zoom().on("zoom", draw).y(yScale)
  
  svg.select("path.line").data([[130,new Date(2013, 0, 1, 12, 0, 0)], [100, new Date(2013, 0, 1, 16, 0, 0)]]);
  
  draw()
  
draw = ->
  svg.select("g.y.axis").call(yAxis)
  svg.select("g.x.axis").call(xAxis)
  svg.select("path.line").attr("d", line)
  # alert("he")
  # svg.select("path.area").attr("d", area);
  # svg.select("path.line").attr("d", line);
